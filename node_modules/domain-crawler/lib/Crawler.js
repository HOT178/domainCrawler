var http = require('http');
var superagent = require('superagent');
var cheerio = require('cheerio');

var Crawler = function(config) {


	var _this = this;
	http.get(config.url, function(res) {
		var html = '';
		res.on('data', function(data) {
			html += data;
		});
		res.on('end', function() {

			_this._init(config, html);
		})
	});
};

// Crawler需要保持静态，可以内部再维护一个crawler

Crawler.prototype._init = function(config, html) {

	// 这个好像会很大，所以需要做清理操作
	// 模块内部定义的全局是属于模块域下的
	config = this.config = config;
	$ = this.$ = cheerio.load(html);
	this.setTags(config["tag"]);
	this.setDomains();
};


Crawler.prototype.getAttrDomain = function (attrs) {
	for(var i in attrs) {
		var elements = traverseDom($("html")[0], attrs[i]); 
	}
};

Crawler.prototype.getCommentDomain = function () {

	var comments = traverseDom($("html")[0], "comment"); 
	var domains = [];
	// !
	var reg = /(http|https):\/\/([^\/]+)\//ig;
	(function(){
		for (var i in comments) {
			var result = comments[i]["nodeValue"].match(reg);
			if(result) {
				for(var j in result) {
					domains.push(result[j].split("/")[2]);
				}
			}
		}
	})();
	return domains;
};

Crawler.prototype.getInlineDomain = function() {
	var inlinescripts = getTags("script").filter(function(item){
		if(item.src === "") { return true; }
		else { return false; }
	});

	var reg = /(http|https):\/\/([^\/]+)\//ig;
	var result = [];
	for(var i in inlinescripts) {
		var matchedDomain = inlinescripts[i].innerHTML.match(reg);
		if(matchedDomain) {
			// 需要遍历
			var domain = (inlinescripts[i].innerHTML.match(reg))[0].split("/")[2];
			result.push(domain);
		}
	}
	return result;
};

Crawler.prototype.setTags = function(tag_map) {


	this.tagInfo = {};
	this.tags = [];
	this.urls = [];
	var tagInfo = this.tagInfo,
		_this = this;
	for(var key in tag_map) {
		var tagName = key;
		tagInfo[tagName] = {};
		var attr = tag_map[key];

		if(typeof(attr) !== "string") {
			for(var i in attr) {
				setTagInfo(tagName, attr[i]);
			}
		} else {
			setTagInfo(tagName, attr);
		}

		function setTagInfo (tagName, attr) {
			var tags = getTags(tagName).filter(function(el){

				// console.log("sss");
				// console.log(el);
				return el.attribs[attr] && el.attribs[attr] !== "";
			});

			// console.log(typeof(Array.prototype.slice.call(tags)));

			// ! 需要处理
			tagInfo[tagName]["tag"] = tagInfo[tagName]["tag"] || [];
			tagInfo[tagName]["url"] = tagInfo[tagName]["url"] || [];
			tagInfo[tagName]["tag"] = tagInfo[tagName]["tag"].concat(tags);
			var urls = tagInfo[tagName]["url"] = tagInfo[tagName]["url"].concat((function(t){
				var tagUrl = [];
				for(var i in t) {
					tagUrl.push(tags[i]["attribs"][attr]);
				}
				return tagUrl;
			})(tags));
			_this.tags = _this.tags.concat(tags);
			_this.urls = _this.urls.concat(urls);

			// console.log(_this.tags);
			// console.log(_this.urls);
		}
	}

};

// 获得一个以域组成的数组
Crawler.prototype.setDomains = function() {

	this.domains = [];
	var urls = this.urls;
	for(var i in urls) {
		var domain = urls[i].split("/")[2];

		// !
		if(domain) {this.domains.push(domain);}
	}

	if (this.config.mode.indexOf("i") !== -1) {
		var inlineDomain = this.getInlineDomain();
		this.domains.concat(inlineDomain);
		this.tagInfo["inlineScript"] = {};
		this.tagInfo["inlineScript"]["domain"] = inlineDomain;
	} 
	if (this.config.mode.indexOf("c") !== -1) {
		var commentDomain = this.getCommentDomain();
		this.domains.concat(commentDomain);
		this.tagInfo["comment"] = {};
		this.tagInfo["comment"]["domain"] = commentDomain;
	}

};

Crawler.prototype.getUniqueDomain = function() {

	return unique(this.domains);

	function unique (array) {
		var n = {},r=[];
		for(var i = 0; i < array.length; i++) 
		{
			if (!n[array[i]]) 
			{
				n[array[i]] = true;
				r.push(array[i]);
			}
		}
		return r;
	}
};


function getTags(tagName) {

	var rawTags = $(tagName);
		tagArray = rawTags.toArray();
	return tagArray;
};

function traverseDom(curr_element, type) { 
   	
	var typeMap = {
		"comment" : {"nodeName" : "#comment", "nodeType" : 8},
		"data-sharpsrc" : {"nodeName" : "data-sharpsrc", "nodeType" : 2}
	};

    var elements = new Array();  
    
    if (curr_element.nodeName == typeMap[type]["nodeName"] || curr_element.nodeType == typeMap[type]["nodeType"]) {     

        elements[elements.length] = curr_element;     
    }    
    else if(curr_element.childNodes.length>0) {    
        for (var i = 0; i<curr_element.childNodes.length; i++) {    
    	
            elements = elements.concat(traverseDom(curr_element.childNodes[i], type));        
        }     
    }   
    return elements;   
};

module.exports = Crawler;